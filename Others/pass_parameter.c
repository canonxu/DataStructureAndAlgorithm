//C语言中有值传参(value)和指针传参(address)两种方式。
//C++中，新增引用(reference)传参。


//值传参/指针传参需开辟新内存，存放拷贝得到的原对象的值/原对象的地址，引用传参不需要开辟新内存，是原对象的“别名”，直接对原对象进行操作
//值传参只改变形参，不改变实参，指针传参改变形参，通过间接操作改变实参，引用传参改变形参，通过直接操作改变实参

//值传递，swap函数内部a，b（形参）拷贝一份实参，有独立内存地址存形参a，b的值，形参确实交换了，实参a，b并未改变。
//值传递是单向的，实参-》形参，参数的值“只能传入，不能传出”，即改变不了main中的实参！！！
void swap1(int a, int b)
{
    int t = a;
    a = b;
    b = t;
}

//指针传递(传址)，swap函数内部得到指向a，b的指针（形参），实际上也是值传递（传递的是地址），有独立内存地址存拷贝到的a，b的地址，根据地址对原对象进行“间接操作”。
//形参确实交换了，函数外部的实参a，b也进行了交换
void swap2(int *a, int *b)
{
    int t = *a;
    *a = *b;
    *b = t;
}

//C++中的引用传递(标准C语言中没有引用，C++中有引用：看作给一个变量起一个“别名”，对引用进行操作就如同对原变量进行操作一样)
//引用传递：不需要额外的内存地址，传递的是实参本身，形参的内存地址与实参内存地址一样，形参交换，实参也交换。
//优势：不需要额外空间，直接对原对象进行操作，传参效率高！
//引用和指针的的区别："指针是变量的地址，引用的变量的别名"。指针变量指向某一对象后，对指向的对象是间接操作，引用的操作是对目标变量的直接操作。
//此行代码在C语言编译器下编译报错，因为C语言不支持引用。
/*void swap3(int &a, int &b)  //此处&并不是取地址，而是引用的标志。如swap3（x， y），则相当于a是x的引用，对a的操作就是对x的操作，a和x内存地址也一样。
{
    int t = a;
    a = b;
    b = t;
}
*/

//注意：数组和函数作形参的时候，自动退化成指针传参。也就是说，数组传给函数调用后，数组可能会被函数修改。
void zero_arr(int array[], int size)
{
    int i = 0;
    for(i = 0; i < size; i++)
        array[i] = 0;
}

int main()
{
   /*
    int x = 1, y = 2;

    swap1(1, 2);  //值传递，swap内函数形参a，b交换，main函数中a，b并无影响。
    printf("%d %d", x, y);  //输出结果为1,2

    swap2(1, 2); //指针传递
    printf("%d %d", x, y);  //输出结果为2,1

    swap3(1, 2);  //引用传递
    printf("%d %d", x, y);  //输出结果为2,1
    */
    int arr[5] = {1, 2, 3, 4, 5};
    zero_arr(arr, 5);
    int i = 0;
    for(i = 0; i < 5; i++)
        printf("%d ", arr[i]);

    return 0;
}
